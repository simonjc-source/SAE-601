"""
üìù **Instructions** :
- Installez toutes les biblioth√®ques n√©cessaires en fonction des imports pr√©sents dans le code, utilisez la commande suivante :conda create -n projet python pandas numpy seaborn streamlit matplotlib.pyplot plotly.express
- Compl√©tez les sections en √©crivant votre code o√π c‚Äôest indiqu√©.
- Ajoutez des commentaires clairs pour expliquer vos choix.
- Utilisez des emoji avec windows + ;
- Interpr√©tez les r√©sultats de vos visualisations (quelques phrases).
"""

# conda create -n projet python pandas numpy matplotlib jupyterlab kagglehub seaborn streamlit plotly
# conda activate projet
# h:
# cd H:\BUT3\SAE\sae_601
# streamlit run application.py


### 1. Importation des librairies et chargement des donn√©es
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import streamlit as st
import plotly.express as px

# Chargement des donn√©es
df = pd.read_csv("ds_salaries.csv") 

titres_onglets = ['Question 2', 'Question 3', 'Question 4', 'Question 5', 'Question 6', 'Question 7', 'Question 8', 'Question 9','Question 10']
onglet1, onglet2, onglet3, onglet4, onglet5, onglet6, onglet7, onglet8, onglet9 = st.tabs(titres_onglets)
with onglet1:
    st.header('Question 2')
    ### 2. Exploration visuelle des donn√©es
    #votre code     
    st.title("üìä Visualisation des Salaires en Data Science")
    st.markdown("Explorez les tendances des salaires √† travers diff√©rentes visualisations interactives.")
    if st.checkbox("Afficher un aper√ßu des donn√©es"):
        st.write(df)
    #Statistique g√©n√©rales avec describe pandas 
    #votre code
    st.subheader("üìå Statistiques g√©n√©rales")
    st.write(df.describe())
 
with onglet2:
    st.header('Question 3')
    ### 3. Distribution des salaires en France par r√¥le et niveau d'exp√©rience, uilisant px.box et st.plotly_chart
    #votre code
    data_france = df[df['company_location']=='FR']
    fig3 = px.box(
        data_france,
        x='job_title', 
        y='salary_in_usd', 
        color='experience_level',
        title='Distribution des salaires en France par m√©tier et niveau d\'exp√©rience',
        labels={'job_title': 'M√©tier', 'salary_in_usd': 'Salaire', 'experience_level': 'Niveau d\'exp√©rience'},
        height=600
    )
    st.subheader("üìà Distribution des salaires en France")
    st.plotly_chart(fig3)
    st.markdown("Ce graphique montre la r√©partition des salaires en France pour divers m√©tiers technologiques, selon trois niveaux d'exp√©rience : d√©butant (SE), interm√©diaire (MI) et expert (EN). On observe que les experts (EN, en rouge) per√ßoivent les salaires les plus √©lev√©s, bien qu'ils soient concentr√©s sur quelques m√©tiers comme 'Data Scientist' ou 'Machine Learning Research Engineer'. Les d√©butants (SE, en bleu fonc√©) ont des salaires plus homog√®nes, avec des m√©tiers tels que 'Data DevOps Engineer' qui se distinguent par des r√©mun√©rations de d√©part sup√©rieures. Les interm√©diaires (MI, en bleu clair) pr√©sentent une plus grande variabilit√©, particuli√®rement pour les postes de 'Data Scientist', refl√©tant des √©carts significatifs entre entreprises et comp√©tences. En r√©sum√©, les m√©tiers li√©s √† la data science et au machine learning sont les plus r√©mun√©rateurs, mais les salaires varient fortement avec l'exp√©rience et le domaine choisi.")

with onglet3:
    st.header('Question 4')
    ### 4. Analyse des tendances de salaires :
    #### Salaire moyen par cat√©gorie : en choisisant une des : ['experience_level', 'employment_type', 'job_title', 'company_location'], utilisant px.bar et st.selectbox
    st.subheader("üìä Analyse des tendances de salaires")
    categories = ['experience_level', 'employment_type', 'job_title', 'company_location']
    selected_category = st.selectbox("cat√©gorie pour analyser le salaire moyen :",categories)
    average_salary = df.groupby(selected_category)['salary_in_usd'].mean().reset_index()
    average_salary = average_salary.rename(columns={'salary_in_usd': 'average_salary'})
    fig4 = px.bar(
        average_salary,
        x=selected_category,
        y='average_salary',
        title=f"Salaire moyen par {selected_category}",
        labels={selected_category: "Cat√©gorie", 'average_salary': "Salaire moyen"},
        height=600
    )   
    st.plotly_chart(fig4)
    st.markdown("Filtre par `experience_level` : Ce graphique montre que les salaires moyens augmentent significativement avec l'exp√©rience. Les experts ont les salaires les plus √©lev√©s, d√©passant largement 200k, tandis que les d√©butants et interm√©diaires se situent autour de 100k.")
    st.markdown("Filtre par `employment_type` : Ce graphique montre que les employ√©s √† temps plein ont les salaires les plus √©lev√©s, d√©passant les 140k en moyenne, suivis par les contrats permanents, qui se situent autour de 100k. Les contrats freelance et √† temps partiel affichent des salaires nettement plus bas, ce qui refl√®te probablement des r√©mun√©rations moins stables et moins comp√©titives.")
    st.markdown("Filtre par `job_title` : Ce graphique montre la forte variabilit√© des salaires selon les m√©tiers. Les postes li√©s au machine learning, √† la data science et aux r√¥les de direction ont les salaires les plus √©lev√©s, d√©passant parfois les 300k. En revanche, des m√©tiers plus techniques ou sp√©cifiques, comme les techniciens ou analystes, ont des salaires moyens plus modestes.")
    st.markdown("Filtre par `company_location` : Ce graphique montre des disparit√©s g√©ographiques importantes dans les salaires moyens. Certaines r√©gions, comme les √âtats-Unis, offrent des salaires bien plus √©lev√©s, d√©passant 250k, tandis que d'autres pays montrent des moyennes beaucoup plus basses.")

with onglet4:
    st.header('Question 5')
    ### 5. Corr√©lation entre variables
    # S√©lectionner uniquement les colonnes num√©riques pour la corr√©lation
    #votre code 
    numeric_columns = df.select_dtypes(include=['float64', 'int64'])
    # Calcul de la matrice de corr√©lation
    #votre code
    correlation_matrix = numeric_columns.corr()
    # Affichage du heatmap avec sns.heatmap
    #votre code
    st.subheader("üìä Corr√©lations entre variables num√©riques")
    plt.figure(figsize=(10, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap="PiYG", cbar=True)
    st.pyplot(plt)
    st.markdown("""
    Ce graphique montre les corr√©lations entre diff√©rentes variables num√©riques. 
    - La variable `work_year` a une corr√©lation positive avec `salary_in_usd` (0.23), mais une corr√©lation n√©gative avec `remote_ratio` (-0.24) et `salary` (-0.095). Cela signifie que plus l'ann√©e de travail augmente, plus les salaires en dollars augmentent, mais moins le travail √† distance est pratiqu√©.
    - La variable `salary` a une faible corr√©lation positive avec `remote_ratio` (0.029), mais presque aucune corr√©lation avec `salary_in_usd` (-0.024). Cela indique que le salaire local n'a pas beaucoup d'impact sur le ratio de t√©l√©travail ou les salaires en dollars.
    - La variable `salary_in_usd` a une faible corr√©lation n√©gative avec `remote_ratio` (-0.064). Cela montre que les salaires en dollars ne d√©pendent pas beaucoup du travail √† distance.
    - La variable `remote_ratio` a une faible corr√©lation positive avec `salary` (0.029) et une corr√©lation n√©gative avec `work_year` (-0.24). Cela montre que le travail √† distance est l√©g√®rement plus courant pour des salaires locaux √©lev√©s, mais tend √† diminuer avec les ann√©es de travail.
    En r√©sum√©, les corr√©lations sont globalement faibles, ce qui signifie qu‚Äôil n‚Äôy a pas de relation forte entre ces variables num√©riques.""")
    


with onglet5:
    st.header('Question 6')
    ### 6. Analyse interactive des variations de salaire
    # Une √©volution des salaires pour les 10 postes les plus courants
    # count of job titles pour selectionner les postes
    # calcule du salaire moyen par an
    #utilisez px.line
    #votre code 
    #10 postes les plus courants
    top_jobs = df['job_title'].value_counts().head(10).index
    #filtre
    filtered_data = df[df['job_title'].isin(top_jobs)]
    #salaire moyen par ann√©e et poste
    salary_trends = (
        filtered_data.groupby(['work_year', 'job_title'])['salary_in_usd']
        .mean()
        .reset_index()
        .rename(columns={'salary_in_usd': 'average_salary'})
    )
    fig6 = px.line(
        salary_trends,
        x='work_year',
        y='average_salary',
        color='job_title',
        title="Evolution des salaires moyens pour les 10 postes les plus courants",
        labels={'work_year': 'Ann√©e', 'average_salary': 'Salaire moyen', 'job_title': 'Poste'},
        markers=True,
        height=600
    )
    st.subheader("üìà Analyse interactive des variations de salaire")
    st.plotly_chart(fig6)
    st.markdown(   
    """
Ce graphique montre l'√©volution des salaires moyens pour les 10 postes les plus courants entre 2020 et 2023.

- Le poste de `Data Scientist` affiche une progression constante, atteignant l'un des salaires les plus √©lev√©s en 2023, au-del√† de 200k.

- Le poste de `Machine Learning Engineer` montre √©galement une augmentation r√©guli√®re, se situant parmi les postes les mieux r√©mun√©r√©s.

- Le poste de `Data Science Manager` conna√Æt une forte augmentation entre 2021 et 2022, d√©passant √©galement 200k en 2023.

- Les postes de `Data Engineer`, `Data Analyst` et `Research Scientist` pr√©sentent des progressions plus modestes mais r√©guli√®res, avec des salaires moyens autour de 100k √† 150k en 2023.

- Le poste de `Applied Scientist` affiche une augmentation rapide apr√®s une chute en 2021, atteignant un niveau comp√©titif en 2023.

- Le poste de `Analytics Engineer` conna√Æt une progression plus mod√©r√©e, restant dans la moyenne basse des salaires observ√©s.

- Les postes de `Data Architect` et `Research Engineer` montrent des variations notables, mais globalement une tendance √† la hausse.

En r√©sum√©, les postes li√©s √† la gestion ou au machine learning sont les plus r√©mun√©rateurs, tandis que les postes d'analyse ou d'ing√©nierie restent stables mais moins comp√©titifs.
""")


with onglet6:
    st.header('Question 7')
    ### 7. Salaire m√©dian par exp√©rience et taille d'entreprise
    # utilisez median(), px.bar
    #votre code 
    #salaire m√©dian par niv d'exp et taille entreprise
    median_salary = (
        df.groupby(['experience_level', 'company_size'])['salary_in_usd']
        .median()
        .reset_index()
        .rename(columns={'salary_in_usd': 'median_salary'})
    )
    fig7 = px.bar(
        median_salary,
        x='experience_level',
        y='median_salary',
        color='company_size',
        barmode='group',
        title="Salaire m√©dian par niveau d'exp√©rience et taille d'entreprise",
        labels={
            'experience_level': 'Niveau d\'exp√©rience',
            'median_salary': 'Salaire m√©dian',
            'company_size': 'Taille d\'entreprise'
        },
        height=600
    )
    st.subheader("üìä Salaire m√©dian par exp√©rience et taille d'entreprise")
    st.plotly_chart(fig7)
    st.markdown(  
    """
Ce graphique montre le salaire m√©dian en fonction du niveau d'exp√©rience et de la taille d'entreprise.

- Pour le niveau `EN` (expert), les salaires m√©dians sont similaires dans les grandes (L), moyennes (M), et petites entreprises (S), autour de 50k.

- Pour le niveau `EX` (exp√©riment√©), les grandes entreprises (L) et les moyennes entreprises (M) offrent des salaires m√©dians proches de 200k, tandis que les petites entreprises (S) restent l√©g√®rement en retrait.

- Pour le niveau `MI` (interm√©diaire), les grandes entreprises (L) et les moyennes entreprises (M) affichent des salaires m√©dians d‚Äôenviron 100k, tandis que les petites entreprises (S) sont nettement plus basses.

- Pour le niveau `SE` (d√©butant), les grandes entreprises (L) ont des salaires l√©g√®rement plus √©lev√©s que les moyennes (M), et les petites entreprises (S) sont en retrait, bien que la diff√©rence soit moins marqu√©e qu'aux autres niveaux.

En r√©sum√©, les grandes et moyennes entreprises tendent √† offrir des salaires plus comp√©titifs, surtout pour les niveaux d'exp√©rience exp√©riment√© (EX) et interm√©diaire (MI).
""")

with onglet7:
    st.header('Question 8')
    ### 8. Ajout de filtres dynamiques
    #Filtrer les donn√©es par salaire utilisant st.slider pour selectionner les plages 
    #votre code 
    st.subheader("üìä Filtre par salaire")
    #slider pour s√©lectionner une plage de salaires
    min_salary = int(df['salary_in_usd'].min())
    max_salary = int(df['salary_in_usd'].max())
    selected_range = st.slider(
        "S√©lectionnez une plage de salaires",
        min_value=min_salary,
        max_value=max_salary,
        value=(min_salary, max_salary)
    )
    #filtre
    filtered_data = df[(df['salary_in_usd'] >= selected_range[0]) & (df['salary_in_usd'] <= selected_range[1])]
    #afficher
    st.write(f"Nb d'entr√©es apr√®s filtre : {len(filtered_data)}")
    st.dataframe(filtered_data)
    st.markdown(
"""
Ce graphique montre un filtre appliqu√© sur les salaires, avec une plage s√©lectionn√©e entre 5,132 et 450,000. Le nombre d‚Äôentr√©es restant apr√®s application du filtre est de 3,755.

- La colonne `work_year` montre que toutes les donn√©es sont pour l'ann√©e 2023.

- La colonne `experience_level` indique que les donn√©es filtr√©es couvrent diff√©rents niveaux d'exp√©rience, incluant `SE` (d√©butant) et `MI` (interm√©diaire).

- La colonne `employment_type` inclut principalement des contrats √† temps plein (`FT`) et quelques contrats temporaires (`CT`).

- La colonne `job_title` montre des postes vari√©s, comme `Principal Data Scientist`, `ML Engineer`, `Data Scientist`, et `Applied Scientist`.

- La colonne `salary` varie de 25,500 USD √† 222,200 USD, avec des monnaies sp√©cifi√©es dans la colonne `salary_currency` (USD et EUR).

En r√©sum√©, ce filtre permet de se concentrer sur une s√©lection de salaires correspondant √† divers postes et niveaux d‚Äôexp√©rience, tout en offrant une vue claire des types d'emploi et des devises associ√©es.
""")


with onglet8:
    st.header('Question 9')
    ### 9.  Impact du t√©l√©travail sur le salaire selon le pays
    #calcul salaire moyen par t√©l√©travail et pays
    remote_salary = (
        df.groupby(['remote_ratio', 'company_location'])['salary_in_usd']
        .mean()
        .reset_index()
        .rename(columns={'salary_in_usd': 'average_salary'})
    )
    fig9 = px.bar(
        remote_salary,
        x='company_location',
        y='average_salary',
        color='remote_ratio',
        barmode='group',
        title="Impact du t√©l√©travail sur le salaire par pays",
        labels={
            'company_location': 'Pays',
            'average_salary': 'Salaire moyen',
            'remote_ratio': 'Ratio de t√©l√©travail'
        },
        height=600
    )
    st.subheader("üìä Impact du t√©l√©travail sur le salaire selon le pays")
    st.plotly_chart(fig9)
    
with onglet9:
    st.header('Question 10')
    ### 10. Filtrage avanc√© des donn√©es avec deux st.multiselect, un qui indique "S√©lectionnez le niveau d'exp√©rience" et l'autre "S√©lectionnez la taille d'entreprise"
    #votre code 
    st.subheader("üîç Filtre des donn√©es")
    #selects
    experience_levels = df['experience_level'].unique().tolist()
    company_sizes = df['company_size'].unique().tolist()

    selected_experience = st.multiselect(
        "S√©lectionnez le niveau d'exp√©rience",
        options=experience_levels,
        default=experience_levels  
    )

    selected_company_size = st.multiselect(
        "S√©lectionnez la taille d'entreprise",
        options=company_sizes,
        default=company_sizes 
    )
    #filtre
    filtered_data = df[
        (df['experience_level'].isin(selected_experience)) &
        (df['company_size'].isin(selected_company_size))
    ]
    #afficher
    st.write(f"Nb d'entr√©es apr√®s filtrage : {len(filtered_data)}")
    st.dataframe(filtered_data)


































